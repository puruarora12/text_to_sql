from langfuse.decorators import observe
from vaul import tool_call
from typing import Dict, Any, List
import re

from app import logger
from app.services.llm.session import LLMSession
from flask import current_app

import json


@tool_call
@observe
def sql_query_validator(
    user_query: str, 
    db_schema: str, 
    context_data: str, 
    generated_sql: str
) -> Dict[str, Any]:
    """
    Validates if the generated SQL query correctly matches the user's intent.
    
    Args:
        user_query: The original natural language query from the user
        db_schema: Database schema information
        context_data: Context data from RAG
        generated_sql: The SQL query generated by text_to_sql
        
    Returns:
        {
            "is_correct": bool,
            "explanation": str,
            "suggestions": list[str],
            "should_regenerate": bool,
            "regeneration_reason": str
        }
    """
    if not generated_sql or not user_query:
        return {
            "is_correct": False,
            "explanation": "Missing SQL query or user query",
            "suggestions": [],
            "should_regenerate": True,
            "regeneration_reason": "Missing required input"
        }
    
    try:
        llm = LLMSession(
            chat_model=current_app.config.get("CHAT_MODEL"),
            embedding_model=current_app.config.get("EMBEDDING_MODEL"),
        )
        
        system_message = (
            "You are an expert SQL query validator. Your job is to analyze whether a generated SQL query "
            "correctly matches the user's natural language intent and is compatible with the database schema.\n\n"
            "EVALUATION CRITERIA:\n"
            "1. **Intent Match**: Does the SQL query address what the user is asking for?\n"
            "2. **Schema Compliance**: Does the query use the correct tables and columns from the schema?\n"
            "3. **Logical Correctness**: Is the query logic sound and complete?\n"
            "4. **Completeness**: Does the query include all necessary conditions and filters?\n"
            "5. **Accuracy**: Will the query return the expected data?\n\n"
            "DECISION LOGIC:\n"
            "- ACCEPT: Query correctly implements user intent and uses valid schema elements\n"
            "- REGENERATE: Query has logical issues, schema mismatches, or doesn't match user intent\n\n"
            "RESPONSE FORMAT:\n"
            "Respond with JSON: {\n"
            '  "is_correct": true|false,\n'
            '  "explanation": "detailed explanation of why the query is correct or incorrect",\n'
            '  "suggestions": ["list of specific improvements"],\n'
            '  "should_regenerate": true|false,\n'
            '  "regeneration_reason": "explanation of why regeneration is needed"\n'
            "}\n\n"
            "Focus on logical correctness and schema compliance rather than confidence scores. "
            "Be thorough in your analysis and provide specific feedback for improvement."
        )
        
        user_message = (
            f"USER QUERY: {user_query}\n\n"
            f"DATABASE SCHEMA:\n{db_schema}\n\n"
            f"CONTEXT DATA:\n{context_data}\n\n"
            f"GENERATED SQL:\n{generated_sql}\n\n"
            "Analyze whether this SQL query correctly matches the user's intent and is compatible with the schema. "
            "Provide a logical assessment and detailed explanation."
        )
        
        response = llm.chat(
            messages=[
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_message},
            ]
        )
        content = response.choices[0].message.content or ""
        
        # Try to parse JSON response
        try:
            # Extract JSON from response
            json_match = re.search(r"```json\s*([\s\S]*?)\s*```", content, re.IGNORECASE)
            if json_match:
                content = json_match.group(1)
            
            parsed = json.loads(content)
            
            # Extract and validate fields
            is_correct = bool(parsed.get("is_correct", False))
            explanation = str(parsed.get("explanation", ""))
            suggestions = list(parsed.get("suggestions", []))
            should_regenerate = bool(parsed.get("should_regenerate", not is_correct))
            regeneration_reason = str(parsed.get("regeneration_reason", ""))
            
            # Determine if regeneration is needed based on correctness
            if not is_correct and not regeneration_reason:
                regeneration_reason = "Query validation failed - logical issues or schema mismatches detected"
            
            return {
                "is_correct": is_correct,
                "explanation": explanation,
                "suggestions": suggestions,
                "should_regenerate": should_regenerate,
                "regeneration_reason": regeneration_reason
            }
            
        except json.JSONDecodeError:
            # Fallback analysis if JSON parsing fails
            logger.warning(f"Failed to parse JSON from SQL validator LLM response: {content[:200]}...")
            return _fallback_validation(user_query, generated_sql, content)
            
    except Exception as e:
        logger.error(f"Error in SQL query validation: {e}")
        return {
            "is_correct": False,
            "explanation": f"Validation failed due to error: {str(e)}",
            "suggestions": ["Check system configuration and try again"],
            "should_regenerate": True,
            "regeneration_reason": "Validation system error"
        }


def _fallback_validation(user_query: str, generated_sql: str, llm_response: str) -> Dict[str, Any]:
    """
    Fallback validation when LLM response cannot be parsed as JSON.
    Enhanced with logical schema comparison.
    """
    # Simple heuristic-based validation
    user_lower = user_query.lower()
    sql_lower = generated_sql.lower()
    
    # Check for basic intent matching
    issues = []
    
    # Check if user wants to select data
    if any(word in user_lower for word in ["show", "get", "find", "select", "display", "list"]):
        if not sql_lower.startswith("select"):
            issues.append("User wants to retrieve data but query doesn't start with SELECT")
    
    # Check if user wants to update data
    if any(word in user_lower for word in ["update", "change", "modify", "set"]):
        if not sql_lower.startswith("update"):
            issues.append("User wants to update data but query doesn't start with UPDATE")
    
    # Check if user wants to insert data
    if any(word in user_lower for word in ["add", "insert", "create", "new"]):
        if not sql_lower.startswith("insert"):
            issues.append("User wants to add data but query doesn't start with INSERT")
    
    # Check if user wants to delete data
    if any(word in user_lower for word in ["delete", "remove", "drop"]):
        if not sql_lower.startswith("delete"):
            issues.append("User wants to delete data but query doesn't start with DELETE")
    
    # Check for specific table mentions
    if "customer" in user_lower and "customer" not in sql_lower:
        issues.append("User mentioned customer but query doesn't reference customer table")
    
    if "user" in user_lower and "user" not in sql_lower:
        issues.append("User mentioned user but query doesn't reference user table")
    
    # Check for schema compliance (basic checks)
    if "main.customer" in sql_lower and "customer" not in user_lower:
        # Check if this is appropriate based on context
        if any(word in user_lower for word in ["data", "information", "show", "get"]):
            pass  # This might be appropriate
        else:
            issues.append("Query references customer table but user didn't mention customers")
    
    # Check for logical completeness
    if sql_lower.startswith("select") and "from" not in sql_lower:
        issues.append("SELECT query missing FROM clause")
    
    if sql_lower.startswith("update") and "set" not in sql_lower:
        issues.append("UPDATE query missing SET clause")
    
    if sql_lower.startswith("update") and "where" not in sql_lower:
        issues.append("UPDATE query missing WHERE clause - could affect all rows")
    
    # Determine if query is correct based on issues
    is_correct = len(issues) == 0
    should_regenerate = not is_correct
    
    return {
        "is_correct": is_correct,
        "explanation": f"Fallback analysis: {'No issues found' if not issues else 'Issues: ' + '; '.join(issues)}",
        "suggestions": issues,
        "should_regenerate": should_regenerate,
        "regeneration_reason": f"Fallback validation found {len(issues)} logical issues" if issues else ""
    }


@tool_call
@observe
def sql_query_refinement(
    user_query: str,
    db_schema: str,
    context_data: str,
    original_sql: str,
    validation_feedback: str,
    suggestions: list
) -> Dict[str, Any]:
    """
    Refines the SQL query based on validation feedback.
    
    Args:
        user_query: The original natural language query
        db_schema: Database schema information
        context_data: Context data from RAG
        original_sql: The original SQL query that failed validation
        validation_feedback: Feedback from the validator
        suggestions: List of suggestions for improvement
        
    Returns:
        {
            "refined_sql": str,
            "improvements_made": list[str],
            "explanation": str
        }
    """
    try:
        llm = LLMSession(
            chat_model=current_app.config.get("CHAT_MODEL"),
            embedding_model=current_app.config.get("EMBEDDING_MODEL"),
        )
        
        system_message = (
            "You are an expert SQL query refiner. Your job is to improve a SQL query based on validation feedback.\n\n"
            "REFINEMENT GUIDELINES:\n"
            "1. **Address Feedback**: Fix the specific issues mentioned in the validation feedback\n"
            "2. **Maintain Intent**: Ensure the refined query still matches the user's original intent\n"
            "3. **Schema Compliance**: Use the correct tables and columns from the provided schema\n"
            "4. **Best Practices**: Follow SQL best practices and security guidelines\n"
            "5. **Completeness**: Include all necessary conditions, filters, and limits\n"
            "6. **Context Awareness**: Consider the user's original query context and intent\n\n"
            "REFINEMENT STRATEGIES:\n"
            "- If query is too broad: Add specific WHERE conditions based on user intent\n"
            "- If query is too narrow: Expand scope while maintaining relevance\n"
            "- If wrong tables: Switch to correct tables mentioned in user query\n"
            "- If missing conditions: Add filters based on user's specific requirements\n"
            "- If unclear intent: Make reasonable assumptions based on context\n"
            "- If schema mismatch: Use correct table/column names from schema\n\n"
            "RESPONSE FORMAT:\n"
            "Respond with JSON: {\n"
            '  "refined_sql": "improved SQL query",\n'
            '  "improvements_made": ["list of specific improvements"],\n'
            '  "explanation": "explanation of what was improved"\n'
            "}\n\n"
            "Generate ONLY the SQL query that addresses the validation issues. "
            "Focus on logical correctness and schema compliance."
        )
        
        user_message = (
            f"USER QUERY: {user_query}\n\n"
            f"DATABASE SCHEMA:\n{db_schema}\n\n"
            f"CONTEXT DATA:\n{context_data}\n\n"
            f"ORIGINAL SQL (with issues):\n{original_sql}\n\n"
            f"VALIDATION FEEDBACK:\n{validation_feedback}\n\n"
            f"SUGGESTIONS FOR IMPROVEMENT:\n" + "\n".join(f"- {s}" for s in suggestions) + "\n\n"
            "Please refine this SQL query to address the validation issues while maintaining the user's intent."
        )
        
        response = llm.chat(
            messages=[
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_message},
            ]
        )
        content = response.choices[0].message.content or ""
        
        # Try to parse JSON response
        try:
            # Extract JSON from response
            json_match = re.search(r"```json\s*([\s\S]*?)\s*```", content, re.IGNORECASE)
            if json_match:
                content = json_match.group(1)
            
            parsed = json.loads(content)
            
            refined_sql = str(parsed.get("refined_sql", ""))
            improvements_made = list(parsed.get("improvements_made", []))
            explanation = str(parsed.get("explanation", ""))
            
            # Extract SQL if it's not in the refined_sql field
            if not refined_sql and "```sql" in content:
                sql_match = re.search(r"```sql\s*([\s\S]*?)\s*```", content, re.IGNORECASE)
                if sql_match:
                    refined_sql = sql_match.group(1).strip()
            
            # If still no SQL found, try to extract from the content
            if not refined_sql:
                # Look for SQL-like content
                lines = content.split('\n')
                for line in lines:
                    line = line.strip()
                    if line and (line.upper().startswith(('SELECT', 'UPDATE', 'INSERT', 'DELETE', 'WITH'))):
                        refined_sql = line
                        break
            
            return {
                "refined_sql": refined_sql,
                "improvements_made": improvements_made,
                "explanation": explanation
            }
            
        except json.JSONDecodeError:
            # Fallback: try to extract SQL from the response
            logger.warning(f"Failed to parse JSON from SQL refiner LLM response: {content[:200]}...")
            return _fallback_refinement(content, original_sql)
            
    except Exception as e:
        logger.error(f"Error in SQL query refinement: {e}")
        return {
            "refined_sql": original_sql,
            "improvements_made": ["Refinement failed due to system error"],
            "explanation": f"Refinement failed: {str(e)}"
        }


def _fallback_refinement(llm_response: str, original_sql: str) -> Dict[str, Any]:
    """
    Fallback refinement when LLM response cannot be parsed as JSON.
    """
    # Try to extract SQL from the response
    sql_match = re.search(r"```sql\s*([\s\S]*?)\s*```", llm_response, re.IGNORECASE)
    if sql_match:
        refined_sql = sql_match.group(1).strip()
        return {
            "refined_sql": refined_sql,
            "improvements_made": ["Extracted SQL from LLM response"],
            "explanation": "Fallback SQL extraction from LLM response"
        }
    
    # If no SQL found, return original with low confidence
    return {
        "refined_sql": original_sql,
        "improvements_made": ["No refinement possible"],
        "explanation": "Could not extract refined SQL from LLM response"
    }


@tool_call
@observe
def human_query_clarification(
    user_query: str,
    db_schema: str,
    context_data: str,
    failed_sql: str = "",
    validation_feedback: str = "",
    attempts: int = 1,
    clarity_analysis: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Requests human clarification when SQL generation has failed or query is too vague.
    Enhanced with context-aware guidance and intent clarity analysis.
    """
    # Use clarity analysis if provided, otherwise analyze the query
    if clarity_analysis:
        vague_aspects = clarity_analysis.get("vague_aspects", [])
        suggested_clarifications = clarity_analysis.get("suggested_clarifications", [])
        clarity_score = clarity_analysis.get("clarity_score", 0.5)
    else:
        vague_aspects = []
        suggested_clarifications = []
        clarity_score = 0.5
    
    # Analyze the type of query to provide better guidance
    user_lower = user_query.lower()
    
    # Determine the type of issue and query intent
    query_analysis = _analyze_query_intent(user_query, db_schema)
    query_type = query_analysis["query_type"]
    action_word = query_analysis["action_word"]
    suggested_tables = query_analysis["suggested_tables"]
    potential_issues = query_analysis["potential_issues"]
    
    # Generate context-aware clarification questions
    clarification_questions = _generate_enhanced_clarifications(
        query_type, action_word, vague_aspects, suggested_tables, db_schema
    )
    
    # Add specific clarifications from intent analysis if available
    if suggested_clarifications:
        clarification_questions.extend(suggested_clarifications)
    
    # Determine the reason for clarification
    if clarity_analysis and clarity_analysis.get("needs_clarification"):
        clarification_reason = "vague_query"
        primary_message = (
            f"I need clarification because your query appears to be too vague or lacks specific details.\n\n"
            f"Your request: \"{user_query}\"\n\n"
            f"Clarity score: {clarity_score:.1f}/1.0\n"
            f"Issues identified: {', '.join(vague_aspects) if vague_aspects else 'General lack of specificity'}\n\n"
        )
    else:
        clarification_reason = "validation_failure"
        primary_message = (
            f"I've tried {attempts} time(s) to generate the correct SQL query for your request, but I'm not confident "
            f"that the generated query matches your intent.\n\n"
            f"Your original request: \"{user_query}\"\n\n"
        )
        if failed_sql:
            primary_message += f"Generated SQL (with issues): {failed_sql}\n\n"
        if validation_feedback:
            primary_message += f"Validation feedback: {validation_feedback}\n\n"
    
    # Enhanced message with context and suggestions
    guidance_section = _generate_contextual_guidance(query_type, action_word, suggested_tables, potential_issues)
    
    full_message = (
        primary_message +
        f"To help me generate the correct query, please provide more specific details about what you want to {action_word}.\n\n" +
        guidance_section +
        "Please provide additional details to help me understand your request better."
    )
    
    return {
        "type": "human_verification",
        "message": full_message,
        "requires_clarification": True,
        "clarification_reason": clarification_reason,
        "clarification_questions": clarification_questions,
        "suggested_tables": suggested_tables,
        "original_query": user_query,
        "failed_sql": failed_sql,
        "validation_feedback": validation_feedback,
        "query_type": query_type,
        "action_word": action_word,
        "clarity_score": clarity_score,
        "vague_aspects": vague_aspects
    }


def _analyze_query_intent(user_query: str, db_schema: str) -> Dict[str, Any]:
    """
    Analyze the user query to determine intent and suggest relevant tables.
    """
    user_lower = user_query.lower()
    
    # Determine query type and action
    if any(word in user_lower for word in ["show", "get", "find", "select", "display", "list", "retrieve", "see", "view"]):
        query_type = "read"
        action_word = "retrieve"
    elif any(word in user_lower for word in ["update", "change", "modify", "set", "edit", "alter"]):
        query_type = "update"
        action_word = "modify"
    elif any(word in user_lower for word in ["add", "insert", "create", "new", "register"]):
        query_type = "insert"
        action_word = "add"
    elif any(word in user_lower for word in ["delete", "remove", "drop", "eliminate"]):
        query_type = "delete"
        action_word = "remove"
    else:
        query_type = "unknown"
        action_word = "work with"
    
    # Extract table suggestions from schema and query
    suggested_tables = []
    if "customer" in user_lower:
        suggested_tables.append("customer")
    if "product" in user_lower:
        suggested_tables.append("product")
    if "time" in user_lower or "date" in user_lower:
        suggested_tables.append("time")
    if "version" in user_lower:
        suggested_tables.append("version")
    
    # If no specific table mentioned, suggest common ones
    if not suggested_tables:
        if query_type == "read":
            suggested_tables = ["customer", "product"]
        else:
            suggested_tables = ["customer"]  # Most common for modifications
    
    # Identify potential issues
    potential_issues = []
    if len(user_query.split()) < 3:
        potential_issues.append("Query is very short")
    if not any(word in user_lower for word in ["where", "with", "for", "that", "which", "=", ">"]):
        potential_issues.append("No specific conditions mentioned")
    if query_type == "unknown":
        potential_issues.append("Unclear what action to perform")
    
    return {
        "query_type": query_type,
        "action_word": action_word,
        "suggested_tables": suggested_tables,
        "potential_issues": potential_issues
    }


def _generate_enhanced_clarifications(
    query_type: str, 
    action_word: str, 
    vague_aspects: List[str], 
    suggested_tables: List[str],
    db_schema: str
) -> List[str]:
    """
    Generate enhanced, context-aware clarification questions.
    """
    clarifications = []
    
    # Type-specific clarifications
    if query_type == "read":
        clarifications.extend([
            f"What specific information would you like to {action_word}?",
            f"Which table contains the data you need? (Available: {', '.join(suggested_tables)})",
            "Do you need all records or specific ones with certain conditions?",
            "Should the results be filtered by date, status, ID, or other criteria?",
            "How many results do you want to see? (e.g., top 10, all, limited to 100)"
        ])
    elif query_type == "update":
        clarifications.extend([
            f"What specific data do you want to {action_word}?",
            "Which records should be updated? (provide specific IDs, conditions, or criteria)",
            "What new values should be set?",
            "Are there any conditions that must be met before updating?",
            "Should I show you the current values before making changes?"
        ])
    elif query_type == "insert":
        clarifications.extend([
            f"What new record do you want to {action_word}?",
            f"Which table should receive the new data? (Available: {', '.join(suggested_tables)})",
            "What values should be set for each field?",
            "Are there any required fields that must be provided?",
            "Should I validate the data before inserting?"
        ])
    elif query_type == "delete":
        clarifications.extend([
            f"What specific records do you want to {action_word}?",
            "Which records should be removed? (provide specific IDs or conditions)",
            "Are you sure you want to permanently delete these records?",
            "Should I show you the records before deleting them?",
            "Are there any related records that should also be considered?"
        ])
    else:
        clarifications.extend([
            "What specific action would you like to perform? (view, update, add, or delete data)",
            "What type of data are you interested in? (customers, products, etc.)",
            "Are you looking to read existing data or make changes?",
            "Could you provide more details about your goal?"
        ])
    
    # Add vague-aspect specific clarifications
    if any("action" in aspect.lower() for aspect in vague_aspects):
        clarifications.append("Please specify what action you want to perform on the data")
    
    if any("entity" in aspect.lower() or "table" in aspect.lower() for aspect in vague_aspects):
        clarifications.append(f"Please specify which type of data you're interested in (suggestions: {', '.join(suggested_tables)})")
    
    # Remove duplicates while preserving order
    seen = set()
    unique_clarifications = []
    for clarification in clarifications:
        if clarification not in seen:
            unique_clarifications.append(clarification)
            seen.add(clarification)
    
    return unique_clarifications


def _generate_contextual_guidance(
    query_type: str, 
    action_word: str, 
    suggested_tables: List[str], 
    potential_issues: List[str]
) -> str:
    """
    Generate contextual guidance based on query analysis.
    """
    guidance_parts = []
    
    # Basic guidance based on query type
    if query_type == "read":
        guidance_parts.append(
            "For data retrieval, please specify:\n"
            "• Which table or type of data (customers, products, etc.)\n"
            "• Any filtering conditions (date ranges, status, IDs)\n"
            "• How many results you want to see\n"
        )
    elif query_type == "update":
        guidance_parts.append(
            "For data updates, please specify:\n"
            "• Which records to update (IDs, conditions)\n"
            "• What values to change\n"
            "• Any conditions that must be met\n"
        )
    elif query_type == "insert":
        guidance_parts.append(
            "For adding new data, please specify:\n"
            "• What table to add data to\n"
            "• What values to set for each field\n"
            "• Any required fields\n"
        )
    elif query_type == "delete":
        guidance_parts.append(
            "For data deletion, please specify:\n"
            "• Which specific records to delete\n"
            "• Clear conditions or IDs\n"
            "• Confirmation of deletion intent\n"
        )
    else:
        guidance_parts.append(
            "Please specify:\n"
            "• What action you want to perform (view, update, add, delete)\n"
            "• What type of data you're working with\n"
            "• Any specific conditions or requirements\n"
        )
    
    # Add table suggestions
    if suggested_tables:
        guidance_parts.append(f"Available tables that might be relevant: {', '.join(suggested_tables)}\n")
    
    # Add issue-specific guidance
    if potential_issues:
        guidance_parts.append(f"Potential issues identified: {', '.join(potential_issues)}\n")
    
    return "\n".join(guidance_parts) + "\n"
